# Integra√ß√£o RabbitMQ - Comunica√ß√£o Ass√≠ncrona

Este documento detalha como a comunica√ß√£o ass√≠ncrona foi implementada entre os apps **clients** e **transactions** usando RabbitMQ.

## üìã Vis√£o Geral

### Arquitetura de Eventos

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Clients App   ‚îÇ                    ‚îÇ Transactions App‚îÇ
‚îÇ   (Producer)    ‚îÇ                    ‚îÇ   (Consumer)    ‚îÇ
‚îÇ                 ‚îÇ                    ‚îÇ                 ‚îÇ
‚îÇ  UsersService   ‚îÇ   RabbitMQ Queue   ‚îÇTransactionsCtrl ‚îÇ
‚îÇ                 ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ                 ‚îÇ
‚îÇ  update() ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚ñ∂‚îÇuser_     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ @EventPattern   ‚îÇ
‚îÇ                 ‚îÇ   ‚îÇevents    ‚îÇ     ‚îÇ handleUser...() ‚îÇ
‚îÇ                 ‚îÇ   ‚îÇ_queue    ‚îÇ     ‚îÇ                 ‚îÇ
‚îÇ                 ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üéØ Evento Implementado

### `user_banking_updated`

Evento emitido quando dados banc√°rios de um usu√°rio s√£o atualizados.

**Campos monitorados:**
- name
- email
- cpf
- phone
- address
- city
- state
- zipCode

## üîß Implementa√ß√£o

### 1. App Clients (Producer)

#### UsersModule

```typescript
import { ClientsModule, Transport } from '@nestjs/microservices';

@Module({
  imports: [
    ClientsModule.register([
      {
        name: 'RABBITMQ_SERVICE',
        transport: Transport.RMQ,
        options: {
          urls: [process.env.RABBITMQ_URL || 'amqp://loomi_user:loomi_password@localhost:5672'],
          queue: 'user_events_queue',
          queueOptions: {
            durable: true,
          },
        },
      },
    ]),
  ],
  // ...
})
export class UsersModule {}
```

#### UsersService

```typescript
import { ClientProxy } from '@nestjs/microservices';

@Injectable()
export class UsersService {
  constructor(
    private readonly prisma: PrismaService,
    @Inject('RABBITMQ_SERVICE') private readonly rabbitClient: ClientProxy,
  ) {}

  async update(id: string, updateUserDto: UpdateUserDto) {
    // Atualiza o usu√°rio
    const updatedUser = await this.prisma.user.update({
      where: { id },
      data: updateUserDto,
      include: { transactions: true },
    });

    // Verifica se campos banc√°rios foram atualizados
    const bankingFieldsUpdated = this.checkBankingFieldsUpdated(updateUserDto);

    if (bankingFieldsUpdated) {
      // Emite evento para o RabbitMQ
      this.rabbitClient.emit('user_banking_updated', {
        userId: updatedUser.id,
        name: updatedUser.name,
        email: updatedUser.email,
        cpf: updatedUser.cpf,
        updatedFields: Object.keys(updateUserDto),
        timestamp: new Date().toISOString(),
      });

      console.log(`üì§ Evento emitido para usu√°rio ${updatedUser.id}`);
    }

    return updatedUser;
  }

  private checkBankingFieldsUpdated(updateUserDto: UpdateUserDto): boolean {
    const bankingFields = ['name', 'email', 'cpf', 'phone', 'address', 'city', 'state', 'zipCode'];
    return bankingFields.some(field => updateUserDto[field] !== undefined);
  }
}
```

### 2. App Transactions (Consumer)

#### main.ts (Modo H√≠brido)

```typescript
import { MicroserviceOptions, Transport } from '@nestjs/microservices';

async function bootstrap() {
  const app = await NestFactory.create(TransactionsModule);

  // Conecta o microservice RabbitMQ (modo h√≠brido)
  app.connectMicroservice<MicroserviceOptions>({
    transport: Transport.RMQ,
    options: {
      urls: [process.env.RABBITMQ_URL || 'amqp://loomi_user:loomi_password@localhost:5672'],
      queue: 'user_events_queue',
      queueOptions: {
        durable: true,
      },
    },
  });

  // Inicia microservices E servidor HTTP
  await app.startAllMicroservices();
  await app.listen(3002);
}
```

#### TransactionsController

```typescript
import { EventPattern, Payload } from '@nestjs/microservices';

interface UserBankingUpdatedEvent {
  userId: string;
  name: string;
  email: string;
  cpf?: string;
  updatedFields: string[];
  timestamp: string;
}

@Controller('api/transactions')
export class TransactionsController {
  // ... HTTP endpoints ...

  @EventPattern('user_banking_updated')
  async handleUserBankingUpdated(@Payload() data: UserBankingUpdatedEvent) {
    console.log('üì• Evento recebido: user_banking_updated');
    console.log('üìã Dados:', data);

    // Buscar transa√ß√µes do usu√°rio
    const userTransactions = await this.transactionsService.findByUserId(data.userId);
    console.log(`‚úÖ Usu√°rio possui ${userTransactions.length} transa√ß√£o(√µes)`);

    // Implementar l√≥gica de neg√≥cio aqui
  }
}
```

## üß™ Como Testar

### Passo 1: Iniciar Servi√ßos

```bash
# Op√ß√£o 1: Apenas infraestrutura (desenvolvimento)
npm run docker:dev:up

# Op√ß√£o 2: Todos os servi√ßos (produ√ß√£o)
npm run docker:up
```

### Passo 2: Iniciar Aplica√ß√µes (se modo dev)

```bash
# Terminal 1
npm run start:clients:dev

# Terminal 2
npm run start:transactions:dev
```

### Passo 3: Criar Usu√°rio

```bash
USER_ID=$(curl -X POST http://localhost:3001/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Jo√£o Silva",
    "email": "joao@example.com",
    "cpf": "123.456.789-00"
  }' | jq -r '.id')

echo "User ID: $USER_ID"
```

### Passo 4: Atualizar Usu√°rio (dispara evento)

```bash
# Atualizar dados banc√°rios
curl -X PATCH http://localhost:3001/api/users/$USER_ID \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Jo√£o Silva Atualizado",
    "phone": "(11) 98765-4321"
  }'
```

### Passo 5: Verificar Logs

**Terminal do Clients App:**
```
üì§ Evento 'user_banking_updated' emitido para o usu√°rio 123e4567-...
```

**Terminal do Transactions App:**
```
üì• Evento recebido: user_banking_updated
üìã Dados do evento: {
  userId: '123e4567-e89b-12d3-a456-426614174000',
  name: 'Jo√£o Silva Atualizado',
  email: 'joao@example.com',
  cpf: '123.456.789-00',
  updatedFields: [ 'name', 'phone' ],
  timestamp: '2024-10-15T15:30:00.000Z'
}
‚úÖ Usu√°rio Jo√£o Silva Atualizado possui 0 transa√ß√£o(√µes)
```

### Passo 6: Monitorar no RabbitMQ UI

Acesse: http://localhost:15672

**Login:** loomi_user / loomi_password

**O que verificar:**
- Queue: `user_events_queue`
- Exchanges
- Mensagens processadas
- Taxa de processamento

## üìä Payload do Evento

### user_banking_updated

```typescript
{
  userId: string;          // UUID do usu√°rio
  name: string;            // Nome atualizado
  email: string;           // Email atualizado
  cpf?: string;            // CPF (opcional)
  updatedFields: string[]; // Lista de campos que foram atualizados
  timestamp: string;       // ISO timestamp do evento
}
```

**Exemplo:**
```json
{
  "userId": "123e4567-e89b-12d3-a456-426614174000",
  "name": "Jo√£o Silva Atualizado",
  "email": "joao.silva@example.com",
  "cpf": "123.456.789-00",
  "updatedFields": ["name", "phone", "address"],
  "timestamp": "2024-10-15T15:30:00.000Z"
}
```

## üéØ Casos de Uso

### 1. Auditoria

Registrar hist√≥rico de altera√ß√µes de usu√°rios:

```typescript
@EventPattern('user_banking_updated')
async handleUserBankingUpdated(@Payload() data: UserBankingUpdatedEvent) {
  // Criar registro de auditoria
  await this.auditService.create({
    event: 'user_banking_updated',
    userId: data.userId,
    changes: data.updatedFields,
    timestamp: data.timestamp,
  });
}
```

### 2. Notifica√ß√µes

Enviar notifica√ß√£o quando dados banc√°rios mudarem:

```typescript
@EventPattern('user_banking_updated')
async handleUserBankingUpdated(@Payload() data: UserBankingUpdatedEvent) {
  // Enviar email de confirma√ß√£o
  await this.notificationService.sendEmail({
    to: data.email,
    subject: 'Dados banc√°rios atualizados',
    template: 'banking-update',
    context: {
      name: data.name,
      updatedFields: data.updatedFields,
    },
  });
}
```

### 3. Sincroniza√ß√£o de Cache

Invalidar cache em outros servi√ßos:

```typescript
@EventPattern('user_banking_updated')
async handleUserBankingUpdated(@Payload() data: UserBankingUpdatedEvent) {
  // Invalidar cache de transa√ß√µes do usu√°rio
  await this.cacheManager.del(`transactions:user:${data.userId}`);
}
```

### 4. Webhooks

Disparar webhooks para sistemas externos:

```typescript
@EventPattern('user_banking_updated')
async handleUserBankingUpdated(@Payload() data: UserBankingUpdatedEvent) {
  // Notificar sistemas externos
  await this.webhookService.trigger('user-updated', data);
}
```

## üîç Debugging

### Ver Mensagens no RabbitMQ

```bash
# 1. Acessar RabbitMQ Management UI
open http://localhost:15672

# 2. Ir para Queues
# 3. Clicar em 'user_events_queue'
# 4. Ver mensagens em 'Get messages'
```

### Logs

**Clients App:**
```
üì§ Evento 'user_banking_updated' emitido para o usu√°rio <userId>
```

**Transactions App:**
```
üì• Evento recebido: user_banking_updated
üìã Dados do evento: { ... }
‚úÖ Usu√°rio <name> possui <count> transa√ß√£o(√µes)
```

### RabbitMQ CLI

```bash
# Listar filas
docker exec -it loomi-rabbitmq rabbitmqctl list_queues

# Ver bindings
docker exec -it loomi-rabbitmq rabbitmqctl list_bindings

# Ver conex√µes
docker exec -it loomi-rabbitmq rabbitmqctl list_connections
```

## ‚öôÔ∏è Configura√ß√£o

### Vari√°veis de Ambiente

```env
# .env
RABBITMQ_URL=amqp://loomi_user:loomi_password@localhost:5672
```

**Em produ√ß√£o (Docker):**
```env
RABBITMQ_URL=amqp://loomi_user:loomi_password@rabbitmq:5672
```

### Queue Options

```typescript
queueOptions: {
  durable: true,  // Persistir mensagens em disco
}
```

**Vantagens:**
- ‚úÖ Mensagens sobrevivem a restart do RabbitMQ
- ‚úÖ Garante entrega mesmo em caso de falha
- ‚úÖ Suporta alta disponibilidade

## üöÄ Benef√≠cios

### 1. Desacoplamento

- ‚úÖ Apps n√£o precisam se conhecer diretamente
- ‚úÖ F√°cil adicionar novos consumidores
- ‚úÖ F√°cil escalar horizontalmente

### 2. Resili√™ncia

- ‚úÖ Mensagens persistidas
- ‚úÖ Retry autom√°tico
- ‚úÖ Dead letter queues (DLQ) configur√°veis

### 3. Performance

- ‚úÖ Ass√≠ncrono - n√£o bloqueia requisi√ß√£o HTTP
- ‚úÖ Processamento em background
- ‚úÖ Load balancing autom√°tico

### 4. Flexibilidade

- ‚úÖ F√°cil adicionar novos eventos
- ‚úÖ M√∫ltiplos consumidores por evento
- ‚úÖ Padr√µes pub/sub e work queues

## üìà Expandindo a Integra√ß√£o

### Adicionar Novo Evento

#### 1. No Producer (Clients)

```typescript
// UsersService
this.rabbitClient.emit('user_created', {
  userId: newUser.id,
  name: newUser.name,
  email: newUser.email,
  timestamp: new Date().toISOString(),
});
```

#### 2. No Consumer (Transactions)

```typescript
// TransactionsController
@EventPattern('user_created')
async handleUserCreated(@Payload() data: any) {
  console.log('üì• Novo usu√°rio criado:', data);
  // Implementar l√≥gica
}
```

### Padr√µes Avan√ßados

#### Request-Response

```typescript
// Producer
const result = await this.rabbitClient.send('get_user_balance', { userId });

// Consumer
@MessagePattern('get_user_balance')
async getUserBalance(@Payload() data: any) {
  return { balance: 1000 };
}
```

#### Multiple Consumers

M√∫ltiplos servi√ßos podem escutar o mesmo evento:

```
user_banking_updated
  ‚îú‚îÄ‚ñ∂ Transactions App (auditoria)
  ‚îú‚îÄ‚ñ∂ Notifications App (email)
  ‚îî‚îÄ‚ñ∂ Analytics App (m√©tricas)
```

## üß™ Testes de Integra√ß√£o

### Teste 1: Evento B√°sico

```bash
# 1. Iniciar servi√ßos
npm run docker:dev:up
npm run start:clients:dev        # Terminal 1
npm run start:transactions:dev   # Terminal 2

# 2. Criar usu√°rio
USER_ID=$(curl -s -X POST http://localhost:3001/api/users \
  -H "Content-Type: application/json" \
  -d '{"name":"Test","email":"test@example.com"}' | jq -r '.id')

# 3. Atualizar e verificar logs
curl -X PATCH http://localhost:3001/api/users/$USER_ID \
  -H "Content-Type: application/json" \
  -d '{"name":"Test Updated"}'

# Ver logs do Transactions App - deve mostrar evento recebido
```

### Teste 2: Campo N√£o-Banc√°rio (n√£o dispara evento)

```bash
# Atualizar apenas transa√ß√µes (n√£o √© campo banc√°rio)
# N√£o deve disparar evento
curl -X PATCH http://localhost:3001/api/users/$USER_ID \
  -H "Content-Type: application/json" \
  -d '{"someOtherField":"value"}'

# Logs n√£o devem mostrar evento
```

### Teste 3: M√∫ltiplos Campos

```bash
# Atualizar v√°rios campos banc√°rios
curl -X PATCH http://localhost:3001/api/users/$USER_ID \
  -H "Content-Type: application/json" \
  -d '{
    "name": "New Name",
    "email": "new@example.com",
    "phone": "123456789",
    "address": "New Address"
  }'

# Ver nos logs: updatedFields deve ter 4 campos
```

## üîí Boas Pr√°ticas

### 1. Valida√ß√£o de Eventos

```typescript
// Definir interface para tipo seguro
interface UserBankingUpdatedEvent {
  userId: string;
  name: string;
  email: string;
  cpf?: string;
  updatedFields: string[];
  timestamp: string;
}

// Usar @Payload() com tipo
@EventPattern('user_banking_updated')
async handleUserBankingUpdated(@Payload() data: UserBankingUpdatedEvent) {
  // TypeScript garante estrutura correta
}
```

### 2. Error Handling

```typescript
@EventPattern('user_banking_updated')
async handleUserBankingUpdated(@Payload() data: UserBankingUpdatedEvent) {
  try {
    await this.processEvent(data);
  } catch (error) {
    console.error('‚ùå Erro ao processar evento:', error);
    // Implementar retry ou DLQ
  }
}
```

### 3. Idempot√™ncia

```typescript
@EventPattern('user_banking_updated')
async handleUserBankingUpdated(@Payload() data: UserBankingUpdatedEvent) {
  // Verificar se j√° processou este evento
  const alreadyProcessed = await this.checkIfProcessed(data.userId, data.timestamp);
  
  if (alreadyProcessed) {
    console.log('‚è≠Ô∏è  Evento j√° processado, pulando...');
    return;
  }

  // Processar evento
  await this.processEvent(data);
}
```

### 4. Logging Estruturado

```typescript
console.log(JSON.stringify({
  event: 'user_banking_updated',
  userId: data.userId,
  fields: data.updatedFields,
  timestamp: data.timestamp,
}));
```

## üìä Monitoramento

### M√©tricas Importantes

1. **Taxa de Mensagens**
   - Mensagens por segundo
   - Mensagens em fila
   - Mensagens processadas

2. **Lat√™ncia**
   - Tempo de processamento
   - Tempo em fila
   - Tempo total (end-to-end)

3. **Erros**
   - Mensagens com erro
   - Retries
   - Dead letters

### RabbitMQ Management UI

http://localhost:15672

**Dashboards:**
- Overview: Estat√≠sticas gerais
- Queues: Status das filas
- Exchanges: Roteamento de mensagens
- Connections: Conex√µes ativas

## üéì Conceitos

### Event-Driven Architecture

- **Producer**: Emite eventos (Clients App)
- **Consumer**: Processa eventos (Transactions App)
- **Broker**: Gerencia mensagens (RabbitMQ)
- **Queue**: Armazena mensagens

### Vantagens

1. ‚úÖ **Desacoplamento**: Servi√ßos independentes
2. ‚úÖ **Escalabilidade**: F√°cil adicionar consumidores
3. ‚úÖ **Resili√™ncia**: Mensagens persistidas
4. ‚úÖ **Flexibilidade**: F√°cil adicionar funcionalidades

### Desvantagens

1. ‚ö†Ô∏è **Complexidade**: Mais componentes para gerenciar
2. ‚ö†Ô∏è **Debugging**: Mais dif√≠cil rastrear fluxo
3. ‚ö†Ô∏è **Eventual Consistency**: Dados podem estar desatualizados temporariamente

## üîÆ Pr√≥ximos Passos

1. **Dead Letter Queue**: Tratar mensagens com erro
2. **Retry Policy**: Configurar retries autom√°ticos
3. **Message TTL**: Expira√ß√£o de mensagens antigas
4. **Priority Queues**: Priorizar mensagens importantes
5. **Multiple Exchanges**: Fan-out, Topic, Headers
6. **Sagas**: Transa√ß√µes distribu√≠das
7. **CQRS**: Separar comandos e queries

## üìö Refer√™ncias

- [NestJS Microservices](https://docs.nestjs.com/microservices/basics)
- [RabbitMQ Tutorials](https://www.rabbitmq.com/getstarted.html)
- [Event-Driven Architecture](https://martinfowler.com/articles/201701-event-driven.html)

